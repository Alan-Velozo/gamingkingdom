rules_version = '2';

service cloud.firestore {
	// Este primer match es siempre el mismo.
  match /databases/{database}/documents {
		// Acá es donde habitualmente vamos a trabajar.
		// Por ahora, veníamos usando la regla a continuación:
    // match /{document=**} {
    //   allow read, write: if true;
    // }
    
    // Esta regla dice que cuando se acceda a un documento (siempre las rutas son a documentos en las
    // reglas) cualquiera de nuestra base de datos (indicado por {document=**}) queremos permitir
    // (allow) acciones de lectura o escritura (read, write) siempre que true sea true (if true).
    // En pocas palabras, permitimos cualquier acción contra nuestra base de datos.
    // Esto lo tuvimos que agregar ya que por defecto Firestore bloquea cualquier petición a la base,
    // a menos de que haya una regla que explícitamente lo permita.
    
    // De más está decir que esto no debería hacerse NUNCA en un sitio en producción.
    // Por eso vamos a ir agregando reglas más granulares para proteger cada uno de nuestros documentos.
    
    // Todas las reglas empiezan con un matcheo de una ruta a un documento de Firestore.
    // Siempre debe ser un documento, nunca una collection.
    // Esto puede ser desde un documento fijo, usando su id, o típicamente una "variable" en el lugar
    // donde estaría el id de documento.
    // Para indicar que un segmento (el del documento) es dinámico (variable) podemos usar la sintaxis:
    // {variable}
    // Por ejemplo, una ruta: 
    // 	match /chat/{message}
    // Indica que queremos matchear un documento de la collection "chat", y que el id lo guardamos en 
    // una variable "message". Esto es útil porque lo podemos usar en la reglas.
    // Dentro del match vamos a tener uno o más "allow"s.
    // Estos van seguidos de qué acciones queremos permitir, seguido de un ":", seguido de qué condiciones 
    // deben cumplirse para permitirse.
    // Como acciones/métodos que podemos permitir podemos poner uno o más de los siguientes:
    // - list: Listar los documentos de la collection. No aplica a este tipo de reglas.
    // - get: Leer el documento (ej: getDoc).
    // - create: Crear el documento (ej: setDoc).
    // - update: Actualizar el documento (ej: updateDoc).
    // - delete: Eliminar el documento (ej: deleteDoc).
    // - read: Combinación de list, get.
    // - write: Combinación de create, update, delete.
    
    // Para las condiciones, por su parte, van a ser condicionales tradicionales como los que conocemos en
    // php o JS. Está incluida la posibilidad de usar operadores lógicos como && o el ||.
    // Además, tenemos el acceso a ciertas variables pre-definidas por las reglas de seguridad:
    // - request: Objeto que contiene datos sobre la petición. Entre sus claves destacadas figura "auth".
    // - request.auth: "auth" contiene un objeto con los datos del usuario autenticado, o es null si no hay 
    // 	un usuario autenticado.
    // - request.resource: Contiene los datos del documento que se está enviando para grabar.
    // - resource: Contiene el contenido del documento al que se está accediendo.
    
    // Empecemos por proteger nuestro chat global.
    // Para nuestro chat global, vamos a pedir lo siguiente:
    // Para leer: El usuario debe estar autenticado.
    // Para crear un mensaje: El usuario debe estar autenticado y debe ser el que firma el mensaje.
    match /chat/{message} {
    	allow read: if request.auth != null;
      
      allow create: if 
      	request.auth != null &&
        // Verificamos que el id/email del usuario autenticado coincide con los que se envian como 
        // contenido del documento.
        request.auth.uid == request.resource.data.user_id;
    }
    
    // Reglas para perfiles de usuarios.
    // Requerimientos:
    // Para leer: El usuario debe estar autenticado.
    // Para crear: El usuario debe estar autenticado y debe estar creando un documento para sí
    //	mismo.
    // Para editar: El usuario debe estar autenticado y debe estar actualizando su propio perfil.
    match /users/{user} {
    	allow read: if request.auth != null;
      
      allow create, update: if
      	request.auth != null &&
        // Verificamos que el id del documento que se está creando coincida con el del usuario
        // autenticado.
        // Para obtener el id del usuario autenticado, hacemos lo que hicimos en el chat.
        // Para obtener el id del documento, podemos usar la variable {user} (sin llaves) que 
        // definimos en el match.
        request.auth.uid == user;
    }
    
    // Reglas para el chat privado.
    // La verificación para el chat privado va a requerir que pongamos reglas tanto para los
    // documentos de la colección raíz, como de la subcolección messages.
    // Para los documentos de la raíz, vamos a pedir:
    // Para leer: El usuario debe estar autenticado y debe ser parte de la conversación.
    // Para crear: El usuario debe estar autenticado y debe ser parte de la conversación.
    match /private-chats/{chat} {
    	// Para verificar si el usuario puede leer el documento, vamos a tener que considerar dos
    	// posibles escenarios:
    	// 1. El documento que se está tratando de leer existe.
    	// 2. El documento que se está tratando de leer *no* existe.
    	// Si el documento existe, entonces permitimos su lectura siempre y cuando el usuario
    	// autenticado sea parte de la conversación.
    	// Si el documento *no* existe, con el fin de que esto no falle, vamos a permitir la 
    	// operación de lectura. De esta forma, nuestro frontend va a poder consultar si el 
    	// documento existe o no.
    	// Esto lo podemos escribir con una serie de operadores lógicos:
    	// allow read: if
    	// request.auth != null &&
    	// (
    	// 		request == null ||
    	// 		(
    	// 			resource != null &&
    	// 			request.auth.uid in resource.data.users
    	// 		)
    	// );
      
      // Como es muy engorroso escribir ese tipo de condiciones, es que Firestore nos permite 
      // tener múltiples reglas (allow) diferentes para cada método de petición en un documento.
      // Aprovechando esto, podemos hacer una primera regla que pregunte si el documento existe
      // y si existe, si el usuario es parte de él.
      allow read: if
      	request.auth != null &&
        // Verificamos si el usuario es parte de la conversación. Para esto, su id debe figurar 
        // como una clave dentro del "mapa" "users" del documento.
        // Para obtener la información del documento que se está tratando de leer, tenemos que 
        // usar la variable especial "resource" (no confundir con "request.resource").
        // Noten que resource solo nos retorna un valor no nulo si el documento existe. Por lo 
        // que no es útil para verificaciones de peticiones de create.
        resource != null &&
        request.auth.uid in resource.data.users;
        
      // Por otro lado, podemos poner otra regla que indique que si el usuario está autenticado
      // y el documento no existe, entonces permitimos la lectura para que se puede saber que no 
      // existe.
      allow read: if
      	request.auth != null &&
        resource == null;
        
      allow create: if
      	request.auth != null &&
        // Verificamos si el usuario es parte de la conversación. Para esto, su id debe figurar 
        // como una clave dentro del "mapa" "users" del documento que se está pidiendo crear.
        // Es decir, del recurso que llega en la petición.
        request.auth.uid in request.resource.data.users;
        
      // Reglas para los mensajes del chat privado.
      // Esto va a requerir:
      // Para leer: El usuario debe estar autenticado y ser parte de la conversación.
      // Para crear: El usuario debe estar autenticado, ser parte de la conversación y ser el que
      //	firma el mensaje.
      // Como queremos probar una subcolección, podemos hacerlo anidando un match dentro del match
      // de los documentos padres de la subcolección.
      match /messages/{message} {
      	allow read: if
          request.auth != null &&
          // En este caso, necesitamos leer la propiedad "users" del documento "padre" de la colección
          // de este documento. Debido a esto, no podemos simplemente escribir "resource", ya que nos
          // retorna los datos del documento que estamos tratando de leer (el del mensaje, no el del
          // chat}.
          // Desafortunadamente, no existe en las reglas de Firebase una propiedad tipo "parent" que
          // nos facilite el acceso al documento padre. Sino que lo vamos a tener que buscar 
          // "manualmente".
          // Esto lo logramos usando la función get(). Esta función debe recibir como argumento la 
          // ruta completa al documento en cuestión.
          // Si necesitamos (y vamos a necesitarlo) usar variables como parte, las variables se 
          // indican: $(variable)
          request.auth.uid in get(/databases/$(database)/documents/private-chats/$(chat)).data.users;
          
        allow create: if
        	request.auth != null &&
          request.auth.uid in get(/databases/$(database)/documents/private-chats/$(chat)).data.users &&
          request.auth.uid == request.resource.data.sender_id;
      }
    }
    
    // match /private-chats/{chat}/messages/{message} {
    //	Alternativa válida para asignar reglas a una subcolección.
    // }
  }
}